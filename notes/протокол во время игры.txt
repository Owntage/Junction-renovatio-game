Во время игры игрок посылает изменения своего персонажа и ждёт изменения других. Когда изменения игрока пришли на сервер, нужно разослать их всем остальным. Каким образом это можно сделать? У игрока есть метод "отправить обновление". У обновления есть тип. Внутри этого метода мы смотрим, есть ли у игрока асинк-контекст. Если его нет, то мы складываем обновления в очередь и когда приходит запрос, мы его сразу исполняем. 
---
Работа с игроком должна быть атомарной. Это значит, что 2 запроса не могут одновременно менять одного игрока. Для этого можно использовать лок. 
---
Где будут храниться игроки? В ConcurrentHashMap. Влияет ли то, находится ли чувак в хэш-мапе, на что-то? Нет, потому что если чувака нет в хэш-мапе, то это значит, что к нему нельзя достучаться из запросов. Если же запрос начал выполняться для какого-то чувака, который вот-вот отключится и в момент исполения этого запроса он таки отключился, то что тогда будет? Тогда есть риск, что для него повиснет асинк-контекст, потому что когда человек отключается, асинк-контекст закрывается. Следовательно нужно гарантировать, что если мы взяли лок, то игрок не будет удалён из мапы. С другой стороны, если игрока собираются удалить из мапы, то нужно сделать для него лок. 
----
----
Как вообще можно модифиировать состояние игрока? Можно либо класть что-то в список его сообщений, либо итерироваться по этому списку и очищать его, когда все обновления отправлены. Можно ли сделать это при помощи методов? Можно, но проще просто взять лок там, где это нужно. 
---
Важно случайно не взять лок 2 раза, чтобы не получился дедлок. 
----
----
Если какого-то поля нет в ответе (потому что оно не задействовано), то нужно всё-равно вставлять пустое поле. 
---
update  ->  interpolator -> getActualPosition
---
Если что-то работает с игроком, то после взятия блокировки нужно убедиться, что игрок всё ещё в мапе. Так как это может потребоваться несокько раз, имеет смысл сделать метод