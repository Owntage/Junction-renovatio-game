Во время игры игрок посылает изменения своего персонажа и ждёт изменения других. Когда изменения игрока пришли на сервер, нужно разослать их всем остальным. Каким образом это можно сделать? У игрока есть метод "отправить обновление". У обновления есть тип. Внутри этого метода мы смотрим, есть ли у игрока асинк-контекст. Если его нет, то мы складываем обновления в очередь и когда приходит запрос, мы его сразу исполняем. 
---
Работа с игроком должна быть атомарной. Это значит, что 2 запроса не могут одновременно менять одного игрока. Для этого можно использовать лок. 
---
Где будут храниться игроки? В ConcurrentHashMap. Влияет ли то, находится ли чувак в хэш-мапе, на что-то? Нет, потому что если чувака нет в хэш-мапе, то это значит, что к нему нельзя достучаться из запросов. Если же запрос начал выполняться для какого-то чувака, который вот-вот отключится и в момент исполения этого запроса он таки отключился, то что тогда будет? Тогда есть риск, что для него повиснет асинк-контекст, потому что когда человек отключается, асинк-контекст закрывается. Следовательно нужно гарантировать, что если мы взяли лок, то игрок не будет удалён из мапы. С другой стороны, если игрока собираются удалить из мапы, то нужно сделать для него лок. 
----
----
Как вообще можно модифиировать состояние игрока? Можно либо класть что-то в список его сообщений, либо итерироваться по этому списку и очищать его, когда все обновления отправлены. Можно ли сделать это при помощи методов? Можно, но проще просто взять лок там, где это нужно. 
---
Важно случайно не взять лок 2 раза, чтобы не получился дедлок. 
----
----
Если какого-то поля нет в ответе (потому что оно не задействовано), то нужно всё-равно вставлять пустое поле. 
---
update  ->  interpolator -> getActualPosition
---
Если что-то работает с игроком, то после взятия блокировки нужно убедиться, что игрок всё ещё в мапе. Так как это может потребоваться несокько раз, имеет смысл сделать метод
----
----
1) отправлять новому игроку обновления остальных игроков. Эти обновления были посланы на сервер до того, как новый игрок подключился. - ок
2) выкидывать игроков, от которых не приходят запросы. Всем остальным рассылать сообщения о том, что игрок отключился
3) сделать башню по центру. У башни есть хп, башне можно наносить урон и чинить. 
4) сделать хп у игроков и возможность его списывать. 
----
----
Новому игроку нужно послать обновления старых игроков, т.е. те обновления, которые пришли до подключения. Здесь может быть проблема: если в обновлении было движение, то нельзя просто так его отправить. Нужно помнить, как давно оно пришло. Т.е. по нему нужно сконструировать новое обновление с новой опорной точкой. Как это сделать? 1) хранить в обновлении время его создания 2) сделать у обновления конструктор, который принимает старое обновление и текущее время. 
----
----
Ещё